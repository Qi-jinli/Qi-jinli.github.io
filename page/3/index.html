<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qi-jinli.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="毕业于大连理工大学机械系，现从事人工智能开发，主要从事机器学习，计算机视觉，自然语言处理等多项领域。">
<meta property="og:type" content="website">
<meta property="og:title" content="Qijinli&#39;s Blog">
<meta property="og:url" content="http://qi-jinli.github.io/page/3/index.html">
<meta property="og:site_name" content="Qijinli&#39;s Blog">
<meta property="og:description" content="毕业于大连理工大学机械系，现从事人工智能开发，主要从事机器学习，计算机视觉，自然语言处理等多项领域。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Qijinli">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://qi-jinli.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Qijinli's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qijinli's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qi-jinli.github.io/2021/05/04/Pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qijinli">
      <meta itemprop="description" content="毕业于大连理工大学机械系，现从事人工智能开发，主要从事机器学习，计算机视觉，自然语言处理等多项领域。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qijinli's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/04/Pandas/" class="post-title-link" itemprop="url">Pandas</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-04 01:29:47" itemprop="dateCreated datePublished" datetime="2021-05-04T01:29:47+08:00">2021-05-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">科学计算库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pandas优势"><a href="#Pandas优势" class="headerlink" title="Pandas优势"></a>Pandas优势</h1><blockquote>
<p><strong>增强图表可读性</strong></p>
<p><strong>便捷的数据处理能力</strong></p>
<p><strong>读取文件方便</strong></p>
<p><strong>封装了Matplotlib、Numpy的画图和计算</strong></p>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><blockquote>
<p>Pandas的数据类型主要有：Series（一维数组），DataFrame（二维数组），Panel（三维数组），PanelND（N维数组）</p>
</blockquote>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><blockquote>
<p>Series是Pandas中最基本的一维数组，可以存储整数、浮点数、字符串等数据。</p>
<pre class=" language-lang-python"><code class="language-lang-python">pandas.Series(data=None,index=None)
</code></pre>
<ol>
<li><code>data</code>可以是字典，或者Numpy中的ndarray</li>
<li><code>index</code>是数据索引</li>
</ol>
<p>例：</p>
<pre class=" language-lang-python"><code class="language-lang-python">s = pandas.Series(&#123;'a': 10, 'b': 20, 'c': 30&#125;)
s = pandas.Series(np.random.randn(5))
</code></pre>
<p><strong>Series的属性</strong></p>
<p><strong>index：索引</strong></p>
<p><strong>values：数据</strong></p>
</blockquote>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><h3 id="DataFrame的创建"><a href="#DataFrame的创建" class="headerlink" title="DataFrame的创建"></a>DataFrame的创建</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">pandas.DataFrame(data=None, index=None, columns=None)
</code></pre>
<p>区别于Series，其增加了columns索引。</p>
<ul>
<li>一维数组、列表、字典或者 Series 字典。</li>
<li>二维或者结构化的 <code>numpy.ndarray</code>。</li>
<li>一个 Series 或者另一个 DataFrame。</li>
</ul>
<p>例：</p>
<ol>
<li>使用由Series组成的字典来构建:</li>
</ol>
<pre class=" language-lang-python"><code class="language-lang-python">pd.DataFrame(&#123;'one': pd.Series([1, 2, 3]),
              'two': pd.Series([4, 5, 6])&#125;)
</code></pre>
<ol>
<li>直接通过列表创建</li>
</ol>
<pre class=" language-lang-python"><code class="language-lang-python">df = pd.DataFrame(&#123;'one': [1, 2, 3],
                   'two': [4, 5, 6]&#125;)
</code></pre>
<ol>
<li>由带字典的列表创建</li>
</ol>
<pre class=" language-lang-python"><code class="language-lang-python">df = pd.DataFrame([&#123;'one': 1, 'two': 4&#125;,
                   &#123;'one': 2, 'two': 5&#125;,
                   &#123;'one': 3, 'two': 6&#125;])
</code></pre>
<ol>
<li>基于二维数值来构建</li>
</ol>
<pre class=" language-lang-python"><code class="language-lang-python">pd.DataFrame(np.random.randint(5, size=(2, 4)))
</code></pre>
</blockquote>
<h3 id="DataFrame的属性"><a href="#DataFrame的属性" class="headerlink" title="DataFrame的属性"></a>DataFrame的属性</h3><p><strong>查看DataFrame属性</strong></p>
<blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">DataFrame.head() # 默认显示前5条
DataFrame.tail(7) # 指定显示后7条
DataFrame.describe()# 对数据集进行概览，会输出每一列数据的计数、最大值、最小值
DataFrame.values # 将DataFrame转换成Numpy数组
DataFrame.index # 查看索引
DataFrame.columns # 查看列名
DataFrame.shape # 查看形状
</code></pre>
</blockquote>
<h3 id="DatatFrame索引的设置"><a href="#DatatFrame索引的设置" class="headerlink" title="DatatFrame索引的设置"></a>DatatFrame索引的设置</h3><blockquote>
<p><strong>修改行列索引值</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">df.index = 新索引值
</code></pre>
<p><strong>重设索引值</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">reset_index(drop=False)
 1.设置新的下标索引
 2.drop:默认为False，不删除原来索引，如果为True,删除原来的索引值
</code></pre>
<p><strong>以某列值设置为新的索引</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">set_index(keys, drop=True)
 1.keys : 列索引名成或者列索引名称的列表
 2.drop : boolean, default True.当做新的索引，删除原来的列
</code></pre>
</blockquote>
<h2 id="MultiIndex与Panel"><a href="#MultiIndex与Panel" class="headerlink" title="MultiIndex与Panel"></a>MultiIndex与Panel</h2><h3 id="MultiIndex"><a href="#MultiIndex" class="headerlink" title="MultiIndex"></a>MultiIndex</h3><p>MultiIndex是三维的数据结构;</p>
<p>多级索引（也称层次化索引）是pandas的重要功能，可以在Series、DataFrame对象上拥有2个以及2个以上的索引。</p>
<blockquote>
<p><strong>multiIndex的特性</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">MultiIndex(levels=[[2012, 2013, 2014], [1, 4, 7, 10]],
           labels=[[0, 2, 1, 2], [0, 1, 2, 3]],
           names=['year', 'month'])
</code></pre>
<p>多级或分层索引对象</p>
<ul>
<li>index属性<ul>
<li>names:levels的名称</li>
<li>levels：每个level的元组值</li>
</ul>
</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">df.index.names
# FrozenList(['year', 'month'])

df.index.levels
# FrozenList([[1, 2], [1, 4, 7, 10]])
</code></pre>
<p><strong>multiIndex的创建</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]
pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))

# 结果
MultiIndex(levels=[[1, 2], ['blue', 'red']],
           codes=[[0, 0, 1, 1], [1, 0, 1, 0]],
           names=['number', 'color'])
</code></pre>
</blockquote>
<h3 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h3><blockquote>
<p><strong>panel的创建</strong></p>
<p><code>pandas.Panel</code>(<em>data=None</em>, <em>items=None</em>, <em>major_axis=None</em>, <em>minor_axis=None</em>)</p>
<ul>
<li>作用：存储3维数组的Panel结构</li>
<li>参数：<ul>
<li><strong>data</strong> : ndarray或者dataframe</li>
<li><strong>items</strong> : 索引或类似数组的对象，axis=0</li>
<li><strong>major_axis</strong> : 索引或类似数组的对象，axis=1</li>
<li><strong>minor_axis</strong> : 索引或类似数组的对象，axis=2</li>
</ul>
</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">p = pd.Panel(data=np.arange(24).reshape(4,3,2),
                 items=list('ABCD'),
                 major_axis=pd.date_range('20130101', periods=3),
                 minor_axis=['first', 'second'])
</code></pre>
<p><strong>查看panel数据</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">p[:,:,"first"]
p["B",:,:]
</code></pre>
<p><strong>注：Pandas从版本0.20.0开始弃用：推荐的用于表示3D数据的方法是通过DataFrame上的MultiIndex方法</strong></p>
</blockquote>
<h1 id="基本数据操作"><a href="#基本数据操作" class="headerlink" title="基本数据操作"></a>基本数据操作</h1><h2 id="数据索引"><a href="#数据索引" class="headerlink" title="数据索引"></a>数据索引</h2><h3 id="基于索引下标进行选择"><a href="#基于索引下标进行选择" class="headerlink" title="基于索引下标进行选择"></a>基于索引下标进行选择</h3><blockquote>
<p>Pandas中的<code>.iloc</code>方法可以基于数字索引对数据集进行选择，可接受的类型：</p>
<ol>
<li>整数。例如：<code>5</code></li>
<li>整数构成的列表或数组。例如：<code>[1, 2, 3]</code></li>
<li>布尔数组。</li>
<li>可返回索引值的函数或参数。</li>
</ol>
<p><code>df.iloc[]</code> 的 <code>[[行]，[列]]</code> 里面可以同时接受行和列的位置</p>
<pre class=" language-lang-python"><code class="language-lang-python">df.iloc[[1, 3, 5]] #选择1，3，5行
df.iloc[:, 1:4] #选择2-4列
</code></pre>
</blockquote>
<h3 id="基于标签名选择"><a href="#基于标签名选择" class="headerlink" title="基于标签名选择"></a>基于标签名选择</h3><blockquote>
<p>除了根据数字索引选择，还可以直接根据标签对应的名称选择。这里用到的方法和上面的 <code>iloc</code> 很相似，少了个 <code>i</code> 为 <code>df.loc[]</code>,可接受类型有：</p>
<ol>
<li>单个标签。例如：<code>2</code> 或 <code>&#39;a&#39;</code>，这里的 <code>2</code> 指的是标签而不是索引位置。</li>
<li>列表或数组包含的标签。例如：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code>。</li>
<li>切片对象。例如：<code>&#39;A&#39;:&#39;E&#39;</code>，注意这里和上面切片的不同之处，首尾都包含在内。</li>
<li>布尔数组。</li>
<li>可返回标签的函数或参数。</li>
</ol>
</blockquote>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><blockquote>
<p>使用df.ix进行下标和名称组合索引</p>
<pre class=" language-lang-python"><code class="language-lang-python">data.ix[0:4, ['open', 'close', 'high', 'low']]
</code></pre>
<p>推荐使用loc和iloc来获取的方式</p>
<pre class=" language-lang-python"><code class="language-lang-python">data.loc[data.index[0:4], ['open', 'close', 'high', 'low']]
data.iloc[0:4, data.columns.get_indexer(['open', 'close', 'high', 'low'])]
</code></pre>
</blockquote>
<h3 id="直接进行索引"><a href="#直接进行索引" class="headerlink" title="直接进行索引"></a>直接进行索引</h3><blockquote>
<p><code>先列后行</code>，按照索引的字符串进行索引</p>
<pre class=" language-lang-python"><code class="language-lang-python">df[列索引值][行索引值]
</code></pre>
<p><strong>不可以先行后列</strong></p>
<p><strong>也不可以传索引下标</strong></p>
</blockquote>
<h2 id="数据赋值"><a href="#数据赋值" class="headerlink" title="数据赋值"></a>数据赋值</h2><blockquote>
<p>将close列赋值为1</p>
<pre class=" language-lang-python"><code class="language-lang-python"># 直接修改原来的值
df['close'] = 1
# 或者
df.close = 1
</code></pre>
</blockquote>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="DataFrame排序"><a href="#DataFrame排序" class="headerlink" title="DataFrame排序"></a>DataFrame排序</h3><blockquote>
<p>使用<code>df.sort_values(by=, ascending=)</code></p>
<ul>
<li>单个键或者多个键进行排序,</li>
<li>参数：<ul>
<li>by：指定排序参考的键，标签名或者列表</li>
<li>ascending:默认升序<ul>
<li>ascending=False:降序</li>
<li>ascending=True:升序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用<code>df.sort_index(axis=)</code>对指定轴索引进行排序，从小到大</p>
</blockquote>
<h3 id="Series排序"><a href="#Series排序" class="headerlink" title="Series排序"></a>Series排序</h3><blockquote>
<ul>
<li>使用<code>series.sort_values(ascending=True)</code>进行升序排序</li>
<li>使用<code>series.sort_index()</code>进行排序</li>
</ul>
</blockquote>
<h2 id="数据删减"><a href="#数据删减" class="headerlink" title="数据删减"></a>数据删减</h2><blockquote>
<p><code>DataFrame.drop</code> 可以直接去掉数据集中指定的列和行。一般在使用时，我们指定 <code>labels</code> 标签参数，然后再通过 <code>axis</code> 指定按列或按行删除即可。</p>
<pre class=" language-lang-python"><code class="language-lang-python">df.drop(labels=['Median Age', 'Total Males'], axis=1)
</code></pre>
<p><code>DataFrame.drop_duplicates</code>则通常用于数据去重，即剔除数据集中的重复值。使用方法非常简单，指定去除重复值规则，以及 <code>axis</code> 按列还是按行去除即可。</p>
<p><code>DataFrame.dropna</code>也十分常用，其主要的用途是删除缺少值，即数据集中空缺的数据列或行。</p>
</blockquote>
<h1 id="DataFrame运算"><a href="#DataFrame运算" class="headerlink" title="DataFrame运算"></a>DataFrame运算</h1><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><blockquote>
<p><code>add(other)</code>:加法运算</p>
<pre class=" language-lang-python"><code class="language-lang-python">df['open'].add(10)
</code></pre>
<p><code>sub(other)</code>：减法运算</p>
</blockquote>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><blockquote>
<p><strong>逻辑运算符号</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">data["open"] > 23返回逻辑结果，布尔值
# 逻辑判断的结果可以作为筛选的依据
data[data["open"] > 23].head()
</code></pre>
<p>完成多个逻辑判断</p>
<pre class=" language-lang-python"><code class="language-lang-python">data[(data["open"] > 23) & (data["open"] < 24)].head()
</code></pre>
<p><strong>逻辑运算函数</strong></p>
<p><code>query(expr)</code></p>
<p><code>expr</code>:查询字符串</p>
<pre class=" language-lang-python"><code class="language-lang-python">data.query("open<24 & open>23").head()
</code></pre>
<p><code>isin(values)</code></p>
<pre class=" language-lang-python"><code class="language-lang-python"># 可以指定值进行一个判断，从而进行筛选操作
data[data["open"].isin([23.53, 23.85])]
</code></pre>
</blockquote>
<h2 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h2><blockquote>
<ol>
<li><code>describe</code></li>
</ol>
<p>综合分析: 能够直接得出很多统计结果,<code>count</code>, <code>mean</code>, <code>std</code>, <code>min</code>, <code>max</code> 等</p>
<pre class=" language-lang-python"><code class="language-lang-python"># 计算平均值、标准差、最大值、最小值
data.describe()
</code></pre>
<ol>
<li><code>统计函数</code>：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sum</code></td>
<td>总和</td>
</tr>
<tr>
<td><code>mean</code></td>
<td>平均值</td>
</tr>
<tr>
<td><code>median</code></td>
<td>中位数</td>
</tr>
<tr>
<td><code>min</code></td>
<td>最小值</td>
</tr>
<tr>
<td><code>max</code></td>
<td>最大值</td>
</tr>
<tr>
<td><code>mode</code></td>
<td>众数</td>
</tr>
<tr>
<td><code>abs</code></td>
<td>绝对值</td>
</tr>
<tr>
<td><code>prod</code></td>
<td>连乘</td>
</tr>
<tr>
<td><code>std</code></td>
<td>标准差</td>
</tr>
<tr>
<td><code>var</code></td>
<td>方差</td>
</tr>
<tr>
<td><code>idxmax</code></td>
<td>最大值索引</td>
</tr>
<tr>
<td><code>idxmin</code></td>
<td>最小值索引</td>
</tr>
<tr>
<td><code>count</code></td>
<td>总样本数</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：对于单个函数去进行统计的时候，坐标轴还是按照默认列“columns” (axis=0, default)，如果要对行“index” 需要指定(axis=1)</strong></p>
<ol>
<li><code>累计统计函数:</code></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cumsum</code></td>
<td><strong>计算前1/2/3/…/n个数的和</strong></td>
</tr>
<tr>
<td><code>cummax</code></td>
<td>计算前1/2/3/…/n个数的最大值</td>
</tr>
<tr>
<td><code>cummin</code></td>
<td>计算前1/2/3/…/n个数的最小值</td>
</tr>
<tr>
<td><code>cumprod</code></td>
<td>计算前1/2/3/…/n个数的积</td>
</tr>
</tbody>
</table>
</div>
<p><code>Dataframe.corr():</code>计算每两列之间的相关性</p>
</blockquote>
<h2 id="自定义运算"><a href="#自定义运算" class="headerlink" title="自定义运算"></a>自定义运算</h2><blockquote>
<p><code>apply(func, axis=0)</code></p>
<ul>
<li>func:自定义函数</li>
<li>axis=0:默认是列，axis=1为行进行运算</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python"># 定义一个对列，最大值-最小值的函数
data[['open', 'close']].apply(lambda x: x.max() - x.min(), axis=0)
</code></pre>
</blockquote>
<h1 id="Pandas画图"><a href="#Pandas画图" class="headerlink" title="Pandas画图"></a>Pandas画图</h1><blockquote>
<ol>
<li><p><code>pandas.DataFrame.plot:</code></p>
<p><code>DataFrame.plot</code>(<em>kind=’line’</em>)</p>
<p><code>kind : str</code>:需要绘制图形的种类</p>
<ul>
<li>‘line’ : line plot (default)</li>
<li>‘bar’ : vertical bar plot</li>
<li>‘barh’ : horizontal bar plot</li>
<li>‘hist’ : histogram</li>
<li>‘pie’ : pie plot</li>
<li>‘scatter’ : scatter plot</li>
</ul>
</li>
<li><p><code>pandas.Series.plot</code></p>
</li>
</ol>
</blockquote>
<h1 id="文件读取与存储"><a href="#文件读取与存储" class="headerlink" title="文件读取与存储"></a>文件读取与存储</h1><h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">pandas.read_csv(filepath_or_buffer, sep =',', usecols=[],engine='python',encoding='utf8'):
</code></pre>
<ul>
<li>filepath_or_buffer:文件路径</li>
<li>sep :分隔符，默认用”,”隔开</li>
<li>usecols:指定读取的列名，列表形式</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">DataFrame.to_csv(path_or_buf=None, sep=', ’, columns=None, header=True, index=True, mode='w', encoding=None):
</code></pre>
<ul>
<li>path_or_buf :文件路径</li>
<li>sep :分隔符，默认用”,”隔开</li>
<li>columns :选择需要的列索引,列表形式</li>
<li>header :是否写进列索引值</li>
<li>index:是否写进行行索引</li>
<li>mode:’w’：重写, ‘a’ 追加</li>
</ul>
</blockquote>
<h2 id="HDF5"><a href="#HDF5" class="headerlink" title="HDF5"></a>HDF5</h2><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">pandas.read_hdf(path_or_buf，key=None，** kwargs):
</code></pre>
<ul>
<li>path_or_buffer:文件路径</li>
<li>key:读取的键</li>
<li>return:Theselected object</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">DataFrame.to_hdf(path_or_buf, key=, **kwargs*)
</code></pre>
<p>查看HD5文件中的所有key值：</p>
<pre class=" language-lang-python"><code class="language-lang-python">pip install h5py
import h5py
f = h5py.File("path","r")
f.keys()
</code></pre>
</blockquote>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">pandas.read_json(path_or_buf=None, orient=None, typ='frame', lines=False):
</code></pre>
<ul>
<li>将JSON格式准换成默认的Pandas DataFrame格式</li>
<li>orient : JSON string format<ul>
<li>‘split’ : dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}<ul>
<li>split 将索引总结到索引，列名到列名，数据到数据。将三部分都分开了</li>
</ul>
</li>
<li>‘records’ : list like [{column -&gt; value}, … , {column -&gt; value}]<ul>
<li>records 以<code>columns：values</code>的形式输出</li>
</ul>
</li>
<li>‘index’ : dict like {index -&gt; {column -&gt; value}}<ul>
<li>index 以<code>index：&#123;columns：values&#125;...</code>的形式输出</li>
</ul>
</li>
<li>‘columns’ : dict like {column -&gt; {index -&gt; value}},默认该格式<ul>
<li>colums 以<code>columns:&#123;index:values&#125;</code>的形式输出</li>
</ul>
</li>
<li>‘values’ : just the values array<ul>
<li>values 直接输出值</li>
</ul>
</li>
</ul>
</li>
<li>lines : 默认False<ul>
<li>按照每行读取json对象</li>
</ul>
</li>
<li>typ : 默认‘frame’， 指定转换成的对象类型series或者dataframe</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">DataFrame.to_json(path_or_buf=None, orient=None, lines=False):
</code></pre>
<ul>
<li>将Pandas 对象存储为json格式</li>
<li><em>path_or_buf=None</em>：文件地址</li>
<li>orient:存储的json形式，{‘split’,’records’,’index’,’columns’,’values’}</li>
<li>lines:一个对象存储为一行</li>
</ul>
</blockquote>
<h1 id="高级处理"><a href="#高级处理" class="headerlink" title="高级处理"></a>高级处理</h1><h2 id="缺失值的处理"><a href="#缺失值的处理" class="headerlink" title="缺失值的处理"></a>缺失值的处理</h2><blockquote>
<p>Pandas 为了更方便地检测缺失值，将不同类型数据的缺失均采用 <code>NaN</code> 标记。这里的 NaN 代表 Not a Number，它仅仅是作为一个标记。例外是，在时间序列里，时间戳的丢失采用 <code>NaT</code> 标记。</p>
<pre class=" language-lang-python"><code class="language-lang-python">np.all(pd.notnull(df)) # 没有缺失值返回True，有返回False
np.any(pd.isnull(df)) # 没有缺失值返回False，有返回True
</code></pre>
<p>Pandas 中用于检测缺失值主要用到两个方法，分别是：<code>isna()</code>和 <code>notna()</code>。</p>
<ol>
<li><p>存在缺失值NaN</p>
<ul>
<li>删除</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python"># 不修改原数据
movie.dropna()
# 可以定义新的变量接受或者用原来的变量名
data = movie.dropna()
</code></pre>
<ul>
<li>替换缺失值</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python"># 替换存在缺失值的样本的两列
# 替换填充平均值，中位数
movie['Revenue (Millions)'].fillna(movie['Revenue (Millions)'].mean(), inplace=True)
</code></pre>
<p>​    b. 替换所有缺失值</p>
<pre class=" language-lang-python"><code class="language-lang-python">for i in movie.columns:
    if np.all(pd.notnull(movie[i])) == False:
        print(i)
        movie[i].fillna(movie[i].mean(), inplace=True)
</code></pre>
</li>
<li><p>不是缺失值nan，有默认标记的</p>
<pre class=" language-lang-python"><code class="language-lang-python"># 全局取消证书验证
import ssl
ssl._create_default_https_context = ssl._create_unverified_context
</code></pre>
<p>先替换‘?’为np.nan</p>
<ul>
<li><pre class=" language-lang-python"><code class="language-lang-python">df.replace(to_replace="?", value=np.nan)
</code></pre>
<ul>
<li>to_replace:替换前的值</li>
<li>value:替换后的值</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><code>缺失值填充</code>：</p>
<pre class=" language-lang-python"><code class="language-lang-python">df.fillna(0) # 用0替换缺失值
df.fillna(method='pad') # 使用缺失值前面的值进行填充
df.fillna(method='bfill') # 使用缺失值前面的值进行填充
df.fillna(method='pad', limit=1)  # 最多填充一项
df.fillna(df.mean()['C':'E']) #对C列到E列用平均值填充
</code></pre>
</blockquote>
<h2 id="插值填充"><a href="#插值填充" class="headerlink" title="插值填充"></a>插值填充</h2><blockquote>
<p>插值是数值分析中一种方法。简而言之，就是借助于一个函数（线性或非线性），再根据已知数据去求解未知数据的值。插值在数据领域非常常见，它的好处在于，可以尽量去还原数据本身的样子。</p>
<p>可以通过<code>interpolate</code>方法完成线性插值。</p>
<pre class=" language-lang-python"><code class="language-lang-python">df = pd.DataFrame(&#123;'A': [1.1, 2.2, np.nan, 4.5, 5.7, 6.9],
                'B': [.21, np.nan, np.nan, 3.1, 11.7, 13.2]&#125;)
df_interpolate = df.interpolate()
</code></pre>
<p>对于 <code>interpolate()</code>支持的插值算法，也就是 <code>method=</code></p>
<ol>
<li>如果你的数据增长速率越来越快，可以选择 <code>method=&#39;quadratic&#39;</code>二次插值。</li>
<li>如果数据集呈现出累计分布的样子，推荐选择 <code>method=&#39;pchip&#39;</code>。</li>
<li>如果需要填补缺省值，以平滑绘图为目标，推荐选择 <code>method=&#39;akima&#39;</code>。</li>
</ol>
<p>需要安装了Scipy库。</p>
</blockquote>
<h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><blockquote>
<p>连续属性离散化的目的是为了简化数据结构，<strong>数据离散化技术可以用来减少给定连续属性值的个数</strong>。离散化方法经常作为数据挖掘的工具。</p>
<p><strong>连续属性的离散化就是在连续属性的值域上，将值域划分为若干个离散的区间，最后用不同的符号或整数</strong> <strong>值代表落在每个子区间中的属性值。</strong></p>
<p><strong>自动分组：</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">pd.qcut(data, num) #将数据分为差不多数量的几组,一般会与value_counts搭配使用，统计每组的个数，num为组数
series.value_counts()：#统计分组次数
</code></pre>
<p><strong>自定义分组：</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">pd.cut(data, bins):
</code></pre>
<p>bins参数为自己定义的分组区间，用列表</p>
<p><strong>分组数据变成one-hot编码：</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">pandas.get_dummies(data, prefix=None)
</code></pre>
<ul>
<li>data:array-like, Series, or DataFrame</li>
<li>prefix:分组名字</li>
</ul>
</blockquote>
<h2 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h2><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">pd.concat([data1, data2], axis=1)
</code></pre>
<p>按照行或列进行合并,axis=0为列索引，axis=1为行索引</p>
<pre class=" language-lang-python"><code class="language-lang-python">pd.merge(left, right, how='inner', on=[]):
</code></pre>
<ul>
<li>可以指定按照两组数据的共同键值对合并或者左右各自</li>
<li><code>left</code>: DataFrame</li>
<li><code>right</code>: 另一个DataFrame</li>
<li><code>on</code>: 指定的共同键，列表</li>
<li><code>how</code>:按照什么方式连接，left，right，outer，inner,默认inner</li>
</ul>
</blockquote>
<h2 id="交叉表和透视表"><a href="#交叉表和透视表" class="headerlink" title="交叉表和透视表"></a>交叉表和透视表</h2><blockquote>
<ul>
<li><p>交叉表：交叉表用于计算一列数据对于另外一列数据的分组个数(用于统计分组频率的特殊透视表)</p>
<pre class=" language-lang-python"><code class="language-lang-python">pd.crosstab(index,columns)
</code></pre>
<p>按index进行分组并作为行索引，并统计columns值的各个频数</p>
</li>
<li><p>透视表：透视表是将原有的DataFrame的列分别作为行索引和列索引，然后对指定的列应用聚集函数</p>
<pre class=" language-lang-python"><code class="language-lang-python">DataFrame.pivot_table(values=[], index=[],aggfunc=np.mean)
</code></pre>
<p>将values按照index分组，默认使用mean()聚合函数</p>
</li>
</ul>
</blockquote>
<h2 id="分组与聚合"><a href="#分组与聚合" class="headerlink" title="分组与聚合"></a>分组与聚合</h2><blockquote>
<p><strong>分组：</strong></p>
<pre class=" language-lang-python"><code class="language-lang-python">DataFrame.groupby(key, as_index=False)
</code></pre>
<p><code>key</code>:分组的列数据，可以多个</p>
<p><strong>聚合：</strong></p>
<p><code>agg(&#123;&quot;列名&quot;：np.聚合函数&#125;)</code></p>
<p><code>max(),min(),mean(),std()</code>等函数</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qi-jinli.github.io/2021/05/04/Numpy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qijinli">
      <meta itemprop="description" content="毕业于大连理工大学机械系，现从事人工智能开发，主要从事机器学习，计算机视觉，自然语言处理等多项领域。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qijinli's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/04/Numpy/" class="post-title-link" itemprop="url">Numpy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-04 01:12:37" itemprop="dateCreated datePublished" datetime="2021-05-04T01:12:37+08:00">2021-05-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">科学计算库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Numpy数组类型"><a href="#Numpy数组类型" class="headerlink" title="Numpy数组类型"></a>Numpy数组类型</h1><blockquote>
<p>Numpy的优势：</p>
<ol>
<li><p><strong>内存风格</strong></p>
<p>ndarray在存储数据的时候，数据与数据的地址都是连续的，这样就给使得批量操作数组元素时速度更快。</p>
</li>
<li><p><strong>ndarray支持并行化运算（向量化运算）</strong></p>
<p>numpy内置了并行运算功能，当系统有多个核心时，做某种计算时，numpy会自动做并行计算</p>
</li>
<li><p><strong>效率远高于纯Python代码</strong></p>
<p>Numpy底层使用C语言编写，内部解除了GIL（全局解释器锁），其对数组的操作速度不受Python解释器的限制，所以，其效率远高于纯Python代码。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">布尔类型，1 个字节，值为 True 或 False。</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">整数类型，通常为 int64 或 int32 。</td>
</tr>
<tr>
<td style="text-align:center">intc</td>
<td style="text-align:center">与 C 里的 int 相同，通常为 int32 或 int64。</td>
</tr>
<tr>
<td style="text-align:center">intp</td>
<td style="text-align:center">用于索引，通常为 int32 或 int64。</td>
</tr>
<tr>
<td style="text-align:center">int8</td>
<td style="text-align:center">字节（从 -128 到 127）</td>
</tr>
<tr>
<td style="text-align:center">int16</td>
<td style="text-align:center">整数（从 -32768 到 32767）</td>
</tr>
<tr>
<td style="text-align:center">int32</td>
<td style="text-align:center">整数（从 -2147483648 到 2147483647）</td>
</tr>
<tr>
<td style="text-align:center">int64</td>
<td style="text-align:center">整数（从 -9223372036854775808 到 9223372036854775807）</td>
</tr>
<tr>
<td style="text-align:center">uint8</td>
<td style="text-align:center">无符号整数（从 0 到 255）</td>
</tr>
<tr>
<td style="text-align:center">uint16</td>
<td style="text-align:center">无符号整数（从 0 到 65535）</td>
</tr>
<tr>
<td style="text-align:center">uint32</td>
<td style="text-align:center">无符号整数（从 0 到 4294967295）</td>
</tr>
<tr>
<td style="text-align:center">uint64</td>
<td style="text-align:center">无符号整数（从 0 到 18446744073709551615）</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">float64 的简写。</td>
</tr>
<tr>
<td style="text-align:center">float16</td>
<td style="text-align:center">半精度浮点，5 位指数，10 位尾数</td>
</tr>
<tr>
<td style="text-align:center">float32</td>
<td style="text-align:center">单精度浮点，8 位指数，23 位尾数</td>
</tr>
<tr>
<td style="text-align:center">float64</td>
<td style="text-align:center">双精度浮点，11 位指数，52 位尾数</td>
</tr>
<tr>
<td style="text-align:center">complex</td>
<td style="text-align:center">complex128 的简写。</td>
</tr>
<tr>
<td style="text-align:center">complex64</td>
<td style="text-align:center">复数，由两个 32 位浮点表示。</td>
</tr>
<tr>
<td style="text-align:center">complex128</td>
<td style="text-align:center">复数，由两个 64 位浮点表示。</td>
</tr>
<tr>
<td style="text-align:center">object_</td>
<td style="text-align:center">python对象</td>
</tr>
<tr>
<td style="text-align:center">string_</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">unicode_</td>
<td style="text-align:center">unicode类型</td>
</tr>
</tbody>
</table>
</div>
<pre class=" language-lang-python"><code class="language-lang-python">import numpy as np
a = np.array([1.1,2.2,3.3],dtype=np.float64)
a.astype(int).dtype # 将a的数值类型从float64转为int64
</code></pre>
</blockquote>
<h1 id="Numpy数组生成"><a href="#Numpy数组生成" class="headerlink" title="Numpy数组生成"></a>Numpy数组生成</h1><blockquote>
<p>Numpy中，ndarray多维数组对象有六个参数：</p>
<ul>
<li>shape：数组的形状</li>
<li>dtype：数组类型</li>
<li>buffer：对象暴露缓冲区接口</li>
<li>offset：数组数据的偏移量</li>
<li>strides：数据步长</li>
<li>order：{‘C’,’F’},以行或列为主排列顺序</li>
</ul>
</blockquote>
<h2 id="列表或元组转换"><a href="#列表或元组转换" class="headerlink" title="列表或元组转换"></a>列表或元组转换</h2><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.array(object,dtype=None,copy=True,order=None,subok=False,ndmin=0)
a1 = numpy.array(a) # 深拷贝
a2 = numpy.asarray(a) # 浅拷贝
</code></pre>
<p>其中参数：</p>
<ol>
<li><code>object</code>：列表、元组等。</li>
<li><code>dtype</code>：数据类型。如果未给出，则类型为被保存对象所需的最小类型。</li>
<li><code>copy</code>：布尔类型，默认 True，表示复制对象。</li>
<li><code>order</code>：顺序。</li>
<li><code>subok</code>：布尔类型，表示子类是否被传递。</li>
<li><code>ndmin</code>：生成的数组应具有的最小维数。</li>
</ol>
</blockquote>
<h2 id="numpy原生方法创建"><a href="#numpy原生方法创建" class="headerlink" title="numpy原生方法创建"></a>numpy原生方法创建</h2><h3 id="arange方法创建"><a href="#arange方法创建" class="headerlink" title="arange方法创建"></a>arange方法创建</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.arange(start,stop,step,dtype=None)
例：numpy.arange(3,7,0.5,dtype='float32')
</code></pre>
<p>arange()的功能是在给定区间内创建一系列均匀间隔的值，指定[开始，停止),并指定步长step</p>
</blockquote>
<h3 id="linspace方法创建"><a href="#linspace方法创建" class="headerlink" title="linspace方法创建"></a>linspace方法创建</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
例：numpy.linspace(0, 10, 10, endpoint=True)
</code></pre>
<p>同arange一样，用于在区间内返回间隔均匀的值。</p>
<ul>
<li><code>start</code>：序列的起始值。</li>
<li><code>stop</code>：序列的结束值。</li>
<li><code>num</code>：生成的样本数。默认值为50。</li>
<li><code>endpoint</code>：布尔值，如果为真，则最后一个样本包含在序列内，默认为True。</li>
<li><code>retstep</code>：布尔值，如果为真，返回间距。</li>
<li><code>dtype</code>：数组的类型。</li>
</ul>
</blockquote>
<h3 id="ones方法创建"><a href="#ones方法创建" class="headerlink" title="ones方法创建"></a>ones方法创建</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.ones(shape, dtype=None, order='C')
numpy.ones_like(a, dtype)
numpy.ones((2, 3))
</code></pre>
<p>Numpy.ones用于快速创建数值全部为1的多维数组</p>
<ul>
<li><code>shape</code>：用于指定数组形状，例如（1， 2）或 3。</li>
<li><code>dtype</code>：数据类型。</li>
<li><code>order</code>：<code>&#123;&#39;C&#39;，&#39;F&#39;&#125;</code>，按行或列方式储存数组。</li>
</ul>
</blockquote>
<h3 id="zeros方法创建"><a href="#zeros方法创建" class="headerlink" title="zeros方法创建"></a>zeros方法创建</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.zeros(shape, dtype=None, order='C')
numpy.zeros_like(a, dtype)
例：np.zeros((3, 2))
</code></pre>
<p>和ones方法相似，只是全部填充为0</p>
<ul>
<li><code>shape</code>：用于指定数组形状，例如<code>（1， 2）</code>或<code>3</code>。</li>
<li><code>dtype</code>：数据类型。</li>
<li><code>order</code>：<code>&#123;&#39;C&#39;，&#39;F&#39;&#125;</code>，按行或列方式储存数组。</li>
</ul>
</blockquote>
<h3 id="eye方法创建"><a href="#eye方法创建" class="headerlink" title="eye方法创建"></a>eye方法创建</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.eye(N, M=None, k=0, dtype=<type 'float'>)
np.eye(5, 4, 3)
</code></pre>
<p>用于创建一个二维数组，特点是k对角线上的值为1，其余值全部为0</p>
<ul>
<li><code>N</code>：输出数组的行数。</li>
<li><code>M</code>：输出数组的列数。</li>
<li><code>k</code>：对角线索引：0（默认）是指主对角线，正值是指上对角线，负值是指下对角线。</li>
</ul>
</blockquote>
<h2 id="从数据文件、函数中创建ndarray"><a href="#从数据文件、函数中创建ndarray" class="headerlink" title="从数据文件、函数中创建ndarray"></a>从数据文件、函数中创建ndarray</h2><p>Numpy提供了下面5个方法：</p>
<blockquote>
<ul>
<li><code>frombuffer（buffer）</code>：将缓冲区转换为 <code>1</code> 维数组。</li>
<li><code>fromfile（file，dtype，count，sep）</code>：从文本或二进制文件中构建多维数组。</li>
<li><code>fromfunction（function，shape）</code>：通过函数返回值来创建多维数组。</li>
<li><code>fromiter（iterable，dtype，count）</code>：从可迭代对象创建 <code>1</code> 维数组。</li>
<li><code>fromstring（string，dtype，count，sep）</code>：从字符串中创建 <code>1</code> 维数组。</li>
</ul>
</blockquote>
<h1 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h1><blockquote>
<ol>
<li><code>ndarray.T</code> 用于数组的转置，与 <code>.transpose()</code> 相同。</li>
<li><code>ndarray.dtype</code> 用来输出数组包含元素的数据类型。</li>
<li><code>ndarray.real</code>用来输出数组包含元素的实部。</li>
<li><code>ndarray.imag</code> 用来输出数组包含元素的虚部。</li>
<li><code>ndarray.size</code>用来输出数组中的总包含元素数。</li>
<li><code>ndarray.itemsize</code>输出一个数组元素的字节数。</li>
<li><code>ndarray.nbytes</code>用来输出数组的元素总字节数。</li>
<li><code>ndarray.ndim</code>用来输出数组维度。</li>
<li><code>ndarray.shape</code>用来输出数组形状。</li>
<li><code>ndarray.strides</code>用来遍历数组时，输出每个维度中步进的字节数组。</li>
</ol>
</blockquote>
<h1 id="数组维度和形状"><a href="#数组维度和形状" class="headerlink" title="数组维度和形状"></a>数组维度和形状</h1><h2 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h2><h3 id="重设形状"><a href="#重设形状" class="headerlink" title="重设形状"></a>重设形状</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.reshape(a, newshape)
</code></pre>
<p><code>reshape</code>可以在不改变数组数据的同时改变数组形状，其中</p>
<p><code>numpy.reshape()</code>等效于<code>ndarray.reshape()</code></p>
<p><code>a</code>表示原数组，<code>newshape</code>表示用于指定新的形状（整数或者数组）</p>
</blockquote>
<h3 id="数组展开"><a href="#数组展开" class="headerlink" title="数组展开"></a>数组展开</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.ravel(a, order='C')
ndarray.flatten()
</code></pre>
<p><code>ravel</code>的目的是将任意形状的数组扁平化，变为1维数组</p>
<p>a代表需要处理的数组，<code>order</code>表示变换时读取的顺序，默认按行依次读取，当<code>order=&#39;F&#39;</code>时按列读取</p>
</blockquote>
<h3 id="轴移动"><a href="#轴移动" class="headerlink" title="轴移动"></a>轴移动</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.moveaxis(a, source, destination)
</code></pre>
<p><code>moveaxis</code>可以将数组的轴移动到新的位置</p>
<ul>
<li><code>a</code>：数组。</li>
<li><code>source</code>：要移动的轴的原始位置。（元组下标）</li>
<li><code>destination</code>：要移动的轴的目标位置。（元组下标）</li>
</ul>
</blockquote>
<h3 id="轴交换"><a href="#轴交换" class="headerlink" title="轴交换"></a>轴交换</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.swapaxes(a, axis1, axis2)
</code></pre>
<p><code>swapaxes</code>可以用来交换数组的轴</p>
<ul>
<li><code>a</code>：数组。</li>
<li><code>axis1</code>：需要交换的轴 1 位置。</li>
<li><code>axis2</code>：需要与轴 1 交换位置的轴 1 位置。</li>
</ul>
</blockquote>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">np.unique(a)
</code></pre>
<p><strong>去重数组元素中重复的元素</strong></p>
</blockquote>
<h3 id="数组转置"><a href="#数组转置" class="headerlink" title="数组转置"></a>数组转置</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.transpose(a, axes=None)
</code></pre>
<p><code>transpose</code>类似于矩阵的转置，可以将二维数组的横轴和纵轴交换</p>
<ul>
<li><code>a</code>：数组。</li>
<li><code>axis</code>：该值默认为 <code>none</code>，表示转置。如果有值，那么则按照值替换轴。</li>
</ul>
</blockquote>
<h3 id="维度改变"><a href="#维度改变" class="headerlink" title="维度改变"></a>维度改变</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.atleast_1d()
numpy.atleast_2d()
numpy.atleast_3d()
</code></pre>
<p><code>atleast_xd</code>支持输入数据直接视为<code>x</code>维，<code>x</code>可以表示：<code>1，2，3</code></p>
</blockquote>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote>
<p>在Numpy中，还有一系列以as开头的方法，可以将特定输入转化为数组，亦可将数组转换为矩阵、标量、ndarray等</p>
<ul>
<li><code>asarray(a，dtype，order)</code>：将特定输入转换为数组。</li>
<li><code>asanyarray(a，dtype，order)</code>：将特定输入转换为 <code>ndarray</code>。</li>
<li><code>asmatrix(data，dtype)</code>：将特定输入转换为矩阵。</li>
<li><code>asfarray(a，dtype)</code>：将特定输入转换为 <code>float</code> 类型的数组。</li>
<li><code>asarray_chkfinite(a，dtype，order)</code>：将特定输入转换为数组，检查 <code>NaN</code> 或 <code>infs</code>。</li>
<li><code>asscalar(a)</code>：将大小为 1 的数组转换为标量。</li>
</ul>
</blockquote>
<h3 id="数组连接"><a href="#数组连接" class="headerlink" title="数组连接"></a>数组连接</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.concatenate((a1, a2, ...), axis=0)
</code></pre>
<p><code>concatenate</code>可以将多个数组沿指定轴连接在一起</p>
<ul>
<li><code>(a1, a2, ...)</code>：需要连接的数组。</li>
<li><code>axis</code>：指定连接轴。为1表示沿着横轴连接</li>
</ul>
</blockquote>
<h3 id="数组堆叠"><a href="#数组堆叠" class="headerlink" title="数组堆叠"></a>数组堆叠</h3><blockquote>
<p>在 NumPy 中，以下方法可用于数组的堆叠：</p>
<ul>
<li><code>stack(arrays，axis)</code>：沿着新轴连接数组的序列。</li>
<li><code>column_stack()</code>：将 1 维数组作为列堆叠到 2 维数组中。</li>
<li><code>hstack()</code>：按水平方向堆叠数组。</li>
<li><code>vstack()</code>：按垂直方向堆叠数组。</li>
<li><code>dstack()</code>：按深度方向堆叠数组。</li>
</ul>
</blockquote>
<h3 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h3><blockquote>
<p><code>split</code> 及与之相似的一系列方法主要是用于数组的拆分，列举如下：</p>
<ul>
<li><code>split(ary，indices_or_sections，axis)</code>：将数组拆分为多个子数组。</li>
<li><code>dsplit(ary，indices_or_sections)</code>：按深度方向将数组拆分成多个子数组。</li>
<li><code>hsplit(ary，indices_or_sections)</code>：按水平方向将数组拆分成多个子数组。</li>
<li><code>vsplit(ary，indices_or_sections)</code>：按垂直方向将数组拆分成多个子数组。</li>
</ul>
</blockquote>
<h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><blockquote>
<ul>
<li><code>delete(arr，obj，axis)</code>：沿特定轴删除数组中的子数组。</li>
<li><code>insert(arr，obj，values，axis)</code>：依据索引在特定轴之前插入值。</li>
<li><code>append(arr，values，axis)</code>：将值附加到数组的末尾，并返回 1 维数组。</li>
<li><code>resize(a，new_shape)</code>：对数组尺寸进行重新设定。</li>
<li><code>fliplr(m)</code>：左右翻转数组。</li>
<li><code>flipud(m)</code>：上下翻转数组。</li>
</ul>
</blockquote>
<h2 id="Numpy随机数"><a href="#Numpy随机数" class="headerlink" title="Numpy随机数"></a>Numpy随机数</h2><blockquote>
<ol>
<li><code>numpy.random.rand(d0, d1, ..., dn)</code> 方法的作用为：指定一个数组，并使用 <code>[0, 1)</code> 区间随机数据填充，这些数据均匀分布。</li>
<li><code>numpy.random.randn(d0, d1, ..., dn)</code> 与 <code>numpy.random.rand(d0, d1, ..., dn)</code> 的区别在于，前者是从标准正态分布中返回一个或多个样本值。</li>
<li><code>randint(low, high, size, dtype)</code> 方法将会生成 <code>[low, high)</code> 的随机整数。注意这是一个半开半闭区间。</li>
<li><code>random_sample(size)</code> 方法将会在 <code>[0, 1)</code> 区间内生成指定 <code>size</code> 的随机浮点数。</li>
<li>与 <code>numpy.random.random_sample</code> 类似的方法还有：<ul>
<li><code>numpy.random.random([size])</code></li>
<li><code>numpy.random.ranf([size])</code></li>
<li><code>numpy.random.sample([size])</code></li>
</ul>
</li>
<li><code>choice(a, size, replace, p)</code> 方法将会给定的数组里随机抽取几个值，该方法类似于随机抽样。</li>
</ol>
</blockquote>
<h2 id="概率密度分布"><a href="#概率密度分布" class="headerlink" title="概率密度分布"></a>概率密度分布</h2><blockquote>
<ul>
<li><code>numpy.random.beta(a，b，size)</code>：从 Beta 分布中生成随机数。</li>
<li><code>numpy.random.binomial(n, p, size)</code>：从二项分布中生成随机数。</li>
<li><code>numpy.random.chisquare(df，size)</code>：从卡方分布中生成随机数。</li>
<li><code>numpy.random.dirichlet(alpha，size)</code>：从 Dirichlet 分布中生成随机数。</li>
<li><code>numpy.random.exponential(scale，size)</code>：从指数分布中生成随机数。</li>
<li><code>numpy.random.f(dfnum，dfden，size)</code>：从 F 分布中生成随机数。</li>
<li><code>numpy.random.gamma(shape，scale，size)</code>：从 Gamma 分布中生成随机数。</li>
<li><code>numpy.random.geometric(p，size)</code>：从几何分布中生成随机数。</li>
<li><code>numpy.random.gumbel(loc，scale，size)</code>：从 Gumbel 分布中生成随机数。</li>
<li><code>numpy.random.hypergeometric(ngood, nbad, nsample, size)</code>：从超几何分布中生成随机数。</li>
<li><code>numpy.random.laplace(loc，scale，size)</code>：从拉普拉斯双指数分布中生成随机数。</li>
<li><code>numpy.random.logistic(loc，scale，size)</code>：从逻辑分布中生成随机数。</li>
<li><code>numpy.random.lognormal(mean，sigma，size)</code>：从对数正态分布中生成随机数。</li>
<li><code>numpy.random.logseries(p，size)</code>：从对数系列分布中生成随机数。</li>
<li><code>numpy.random.multinomial(n，pvals，size)</code>：从多项分布中生成随机数。</li>
<li><code>numpy.random.multivariate_normal(mean, cov, size)</code>：从多变量正态分布绘制随机样本。</li>
<li><code>numpy.random.negative_binomial(n, p, size)</code>：从负二项分布中生成随机数。</li>
<li><code>numpy.random.noncentral_chisquare(df，nonc，size)</code>：从非中心卡方分布中生成随机数。</li>
<li><code>numpy.random.noncentral_f(dfnum, dfden, nonc, size)</code>：从非中心 F 分布中抽取样本。</li>
<li><code>numpy.random.normal(loc，scale，size)</code>：==从正态分布绘制随机样本。参数，均值和偏差==</li>
<li><code>numpy.random.pareto(a，size)</code>：从具有指定形状的 Pareto II 或 Lomax 分布中生成随机数。</li>
<li><code>numpy.random.poisson(lam，size)</code>：从泊松分布中生成随机数。</li>
<li><code>numpy.random.power(a，size)</code>：从具有正指数 a-1 的功率分布中在 0，1 中生成随机数。</li>
<li><code>numpy.random.randn(d0,d1,....dn)</code>:从标准正态分布中返回一个或多个样本值</li>
<li><code>numpy.random.randint(low, high=None, size=None, dtype=&#39;l&#39;)</code>:从一个从一个均匀分布中随机采样，生成一个整数或N维整数数组</li>
<li><code>numpy.random.rayleigh(scale，size)</code>：从瑞利分布中生成随机数。</li>
<li><code>numpy.random.standard_cauchy(size)</code>：从标准 Cauchy 分布中生成随机数。</li>
<li><code>numpy.random.standard_exponential(size)</code>：从标准指数分布中生成随机数。</li>
<li><code>numpy.random.standard_gamma(shape，size)</code>：从标准 Gamma 分布中生成随机数。</li>
<li><code>numpy.random.standard_normal(size)</code>：从标准正态分布中生成随机数。</li>
<li><code>numpy.random.standard_t(df，size)</code>：从具有 df 自由度的标准学生 t 分布中生成随机数。</li>
<li><code>numpy.random.triangular(left，mode，right，size)</code>：从三角分布中生成随机数。</li>
<li><code>numpy.random.uniform(low=0，high=1，size)</code>：从均匀分布中生成随机数。</li>
<li><code>numpy.random.vonmises(mu，kappa，size)</code>：从 von Mises 分布中生成随机数。</li>
<li><code>numpy.random.wald(mean，scale，size)</code>：从 Wald 或反高斯分布中生成随机数。</li>
<li><code>numpy.random.weibull(a，size)</code>：从威布尔分布中生成随机数。</li>
<li><code>numpy.random.zipf(a，size)</code>：从 Zipf 分布中生成随机数。</li>
</ul>
</blockquote>
<h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><blockquote>
<ul>
<li><code>numpy.sin(x)</code>：三角正弦。</li>
<li><code>numpy.cos(x)</code>：三角余弦。</li>
<li><code>numpy.tan(x)</code>：三角正切。</li>
<li><code>numpy.arcsin(x)</code>：三角反正弦。</li>
<li><code>numpy.arccos(x)</code>：三角反余弦。</li>
<li><code>numpy.arctan(x)</code>：三角反正切。</li>
<li><code>numpy.hypot(x1,x2)</code>：直角三角形求斜边。</li>
<li><code>numpy.degrees(x)</code>：弧度转换为度。</li>
<li><code>numpy.radians(x)</code>：度转换为弧度。</li>
<li><code>numpy.deg2rad(x)</code>：度转换为弧度。</li>
<li><code>numpy.rad2deg(x)</code>：弧度转换为度。</li>
</ul>
</blockquote>
<h2 id="双曲线函数"><a href="#双曲线函数" class="headerlink" title="双曲线函数"></a>双曲线函数</h2><blockquote>
<ul>
<li><code>numpy.sinh(x)</code>：双曲正弦。</li>
<li><code>numpy.cosh(x)</code>：双曲余弦。</li>
<li><code>numpy.tanh(x)</code>：双曲正切。</li>
<li><code>numpy.arcsinh(x)</code>：反双曲正弦。</li>
<li><code>numpy.arccosh(x)</code>：反双曲余弦。</li>
<li><code>numpy.arctanh(x)</code>：反双曲正切。</li>
</ul>
</blockquote>
<h2 id="数值修约"><a href="#数值修约" class="headerlink" title="数值修约"></a>数值修约</h2><blockquote>
<ul>
<li><code>numpy.around(a)</code>：平均到给定的小数位数。</li>
<li><code>numpy.round_(a)</code>：将数组舍入到给定的小数位数。</li>
<li><code>numpy.rint(x)</code>：修约到最接近的整数。</li>
<li><code>numpy.fix(x, y)</code>：向 0 舍入到最接近的整数。</li>
<li><code>numpy.floor(x)</code>：返回输入的底部(标量 x 的底部是最大的整数 i)。</li>
<li><code>numpy.ceil(x)</code>：返回输入的上限(标量 x 的底部是最小的整数 i).</li>
<li><code>numpy.trunc(x)</code>：返回输入的截断值。</li>
</ul>
</blockquote>
<h2 id="求和、求积、差分"><a href="#求和、求积、差分" class="headerlink" title="求和、求积、差分"></a>求和、求积、差分</h2><blockquote>
<ul>
<li><code>numpy.prod(a, axis, dtype, keepdims)</code>：返回指定轴上的数组元素的乘积。</li>
<li><code>numpy.sum(a, axis, dtype, keepdims)</code>：返回指定轴上的数组元素的总和。</li>
<li><code>numpy.nanprod(a, axis, dtype, keepdims)</code>：返回指定轴上的数组元素的乘积, 将 NaN 视作 1。</li>
<li><code>numpy.nansum(a, axis, dtype, keepdims)</code>：返回指定轴上的数组元素的总和, 将 NaN 视作 0。</li>
<li><code>numpy.cumprod(a, axis, dtype)</code>：返回沿给定轴的元素的累积乘积。</li>
<li><code>numpy.cumsum(a, axis, dtype)</code>：返回沿给定轴的元素的累积总和。</li>
<li><code>numpy.nancumprod(a, axis, dtype)</code>：返回沿给定轴的元素的累积乘积, 将 NaN 视作 1。</li>
<li><code>numpy.nancumsum(a, axis, dtype)</code>：返回沿给定轴的元素的累积总和, 将 NaN 视作 0。</li>
<li><code>numpy.diff(a, n, axis)</code>：计算沿指定轴的第 n 个离散差分。</li>
<li><code>numpy.ediff1d(ary, to_end, to_begin)</code>：数组的连续元素之间的差异。</li>
<li><code>numpy.gradient(f)</code>：返回 N 维数组的梯度。</li>
<li><code>numpy.cross(a, b, axisa, axisb, axisc, axis)</code>：返回两个(数组）向量的叉积。</li>
<li><code>numpy.trapz(y, x, dx, axis)</code>：使用复合梯形规则沿给定轴积分。</li>
</ul>
</blockquote>
<h2 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h2><blockquote>
<ul>
<li><code>numpy.exp(x)</code>：计算输入数组中所有元素的指数。</li>
<li><code>numpy.log(x)</code>：计算自然对数。</li>
<li><code>numpy.log10(x)</code>：计算常用对数。</li>
<li><code>numpy.log2(x)</code>：计算二进制对数。</li>
</ul>
</blockquote>
<h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><blockquote>
<ul>
<li><code>numpy.add(x1, x2)</code>：对应元素相加。</li>
<li><code>numpy.reciprocal(x)</code>：求倒数 1/x。</li>
<li><code>numpy.negative(x)</code>：求对应负数。</li>
<li><code>numpy.multiply(x1, x2)</code>：求解乘法。</li>
<li><code>numpy.divide(x1, x2)</code>：相除 x1/x2。</li>
<li><code>numpy.power(x1, x2)</code>：类似于 x1^x2。</li>
<li><code>numpy.subtract(x1, x2)</code>：减法。</li>
<li><code>numpy.fmod(x1, x2)</code>：返回除法的元素余项。</li>
<li><code>numpy.mod(x1, x2)</code>：返回余项。</li>
<li><code>numpy.modf(x1)</code>：返回数组的小数和整数部分。</li>
<li><code>numpy.remainder(x1, x2)</code>：返回除法余数</li>
</ul>
</blockquote>
<h2 id="逻辑运算和判断函数"><a href="#逻辑运算和判断函数" class="headerlink" title="逻辑运算和判断函数"></a>逻辑运算和判断函数</h2><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">a[条件] = 1 # 将满足条件的数组元素设置为1
np.all(条件) # 查询是否都满足条件
numpy.any(条件) # 查询是否有满足条件的
numpy.where(条件，1，0) # 三目运算，符合条件的设置为1，不符合的为0
</code></pre>
</blockquote>
<h2 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h2><blockquote>
<ul>
<li><code>np.max()</code> 沿指定轴计算中间值</li>
<li><code>np.min()</code>沿指定轴计算中间值</li>
<li><code>np.median()</code> 沿指定轴计算中间值</li>
<li><code>np.mean()</code>沿指定轴计算平均数</li>
<li><code>np.std()</code>沿指定轴计算标准偏差</li>
<li><code>np.var()</code>沿指定轴计算方差</li>
<li><code>np.argmax(axis=)</code>最大元素对应的下标</li>
<li><code>np.argmin(axis=)</code> 最小元素对应的下标</li>
</ul>
</blockquote>
<h2 id="矩阵和向量积"><a href="#矩阵和向量积" class="headerlink" title="矩阵和向量积"></a>矩阵和向量积</h2><blockquote>
<ul>
<li><code>numpy.dot(a, b)</code>：求解两个数组的点积。</li>
<li><code>numpy.vdot(a, b)</code>：求解两个向量的点积。</li>
<li><code>numpy.inner(a, b)</code>：求解两个数组的内积。</li>
<li><code>numpy.outer(a, b)</code>：求解两个向量的外积。</li>
<li><code>numpy.matmul(a, b)</code>：求解两个数组的矩阵乘积。</li>
<li><code>numpy.tensordot(a, b)</code>：求解张量点积。</li>
<li><code>numpy.kron(a, b)</code>：计算 Kronecker 乘积。</li>
</ul>
</blockquote>
<h2 id="代数运算"><a href="#代数运算" class="headerlink" title="代数运算"></a>代数运算</h2><blockquote>
<ul>
<li><code>numpy.linalg.cholesky(a)</code>：Cholesky 分解。</li>
<li><code>numpy.linalg.qr(a ,mode)</code>：计算矩阵的 QR 因式分解。</li>
<li><code>numpy.linalg.svd(a ,full_matrices,compute_uv)</code>：奇异值分解。</li>
<li><code>numpy.linalg.eig(a)</code>：计算正方形数组的特征值和右特征向量。</li>
<li><code>numpy.linalg.eigh(a, UPLO)</code>：返回 Hermitian 或对称矩阵的特征值和特征向量。</li>
<li><code>numpy.linalg.eigvals(a)</code>：计算矩阵的特征值。</li>
<li><code>numpy.linalg.eigvalsh(a, UPLO)</code>：计算 Hermitian 或真实对称矩阵的特征值。</li>
<li><code>numpy.linalg.norm(x ,ord,axis,keepdims)</code>：计算矩阵或向量范数。</li>
<li><code>numpy.linalg.cond(x ,p)</code>：计算矩阵的条件数。</li>
<li><code>numpy.linalg.det(a)</code>：计算数组的行列式。</li>
<li><code>numpy.linalg.matrix_rank(M ,tol)</code>：使用奇异值分解方法返回秩。</li>
<li><code>numpy.linalg.slogdet(a)</code>：计算数组的行列式的符号和自然对数。</li>
<li><code>numpy.trace(a ,offset,axis1,axis2,dtype,out)</code>：沿数组的对角线返回总和。</li>
<li><code>numpy.linalg.solve(a, b)</code>：求解线性矩阵方程或线性标量方程组。</li>
<li><code>numpy.linalg.tensorsolve(a, b ,axes)</code>：为 x 解出张量方程 a x = b</li>
<li><code>numpy.linalg.lstsq(a, b ,rcond)</code>：将最小二乘解返回到线性矩阵方程。</li>
<li><code>numpy.linalg.inv(a)</code>：计算逆矩阵。</li>
<li><code>numpy.linalg.pinv(a ,rcond)</code>：计算矩阵的（Moore-Penrose）伪逆。</li>
<li><code>numpy.linalg.tensorinv(a ,ind)</code>：计算 N 维数组的逆。</li>
</ul>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<ul>
<li><code>numpy.angle(z, deg)</code>：返回复参数的角度。</li>
<li><code>numpy.real(val)</code>：返回数组元素的实部。</li>
<li><code>numpy.imag(val)</code>：返回数组元素的虚部。</li>
<li><code>numpy.conj(x)</code>：按元素方式返回共轭复数。</li>
<li><code>numpy.convolve(a, v, mode)</code>：返回线性卷积。</li>
<li><code>numpy.sqrt(x)</code>：平方根。</li>
<li><code>numpy.cbrt(x)</code>：立方根。</li>
<li><code>numpy.square(x)</code>：平方。</li>
<li><code>numpy.absolute(x)</code>：绝对值, 可求解复数。</li>
<li><code>numpy.fabs(x)</code>：绝对值。</li>
<li><code>numpy.sign(x)</code>：符号函数。</li>
<li><code>numpy.maximum(x1, x2)</code>：最大值。</li>
<li><code>numpy.minimum(x1, x2)</code>：最小值。</li>
<li><code>numpy.nan_to_num(x)</code>：用 0 替换 NaN。</li>
<li><code>numpy.interp(x, xp, fp, left, right, period)</code>：线性插值。</li>
</ul>
</blockquote>
<h1 id="数组索引和切片"><a href="#数组索引和切片" class="headerlink" title="数组索引和切片"></a>数组索引和切片</h1><h2 id="数据索引"><a href="#数据索引" class="headerlink" title="数据索引"></a>数据索引</h2><blockquote>
<ol>
<li>一维数组索引：</li>
</ol>
<pre class=" language-lang-python"><code class="language-lang-python">a=np.arange(10)
a[1] #获取索引值为1的数据
a[[1,2,3]] #分别获取索引值1，2，3的数据
</code></pre>
<ol>
<li>二维数组索引：</li>
</ol>
<pre class=" language-lang-python"><code class="language-lang-python">a = np.arange(20).reshape(4, 5)
a[[1,2],[3,4]] # 获取第2行，第3列的数据
</code></pre>
<ol>
<li>三维数组索引：</li>
</ol>
<pre class=" language-lang-python"><code class="language-lang-python">a = np.arange(30).reshape(2, 5, 3)
a[[0, 1], [1, 2], [1, 2]]
</code></pre>
</blockquote>
<h2 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h2><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">Ndarray[start:stop:step]
</code></pre>
<p><code>[start:stop:step]</code> 分别代表 <code>[起始索引:截至索引:步长]</code>。</p>
<p>一维数组：a[5:10]</p>
<p>二维数组：[0:3, 2:4]</p>
</blockquote>
<h2 id="排序、搜索、计数"><a href="#排序、搜索、计数" class="headerlink" title="排序、搜索、计数"></a>排序、搜索、计数</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<pre class=" language-lang-python"><code class="language-lang-python">numpy.sort(a, axis=-1, kind='quicksort', order=None)
</code></pre>
<ul>
<li><code>a</code>：数组。</li>
<li><code>axis</code>：要排序的轴。如果为<code>None</code>，则在排序之前将数组铺平。默认值为 <code>-1</code>，沿最后一个轴排序。</li>
<li><code>kind</code>：<code>&#123;&#39;quicksort&#39;，&#39;mergesort&#39;，&#39;heapsort&#39;&#125;</code>，排序算法。默认值为 <code>quicksort</code>。</li>
</ul>
<p>其他排序方法：</p>
<ul>
<li><code>numpy.lexsort(keys ,axis)</code>：使用多个键进行间接排序。</li>
<li><code>numpy.argsort(a ,axis,kind,order)</code>：沿给定轴执行间接排序。</li>
<li><code>numpy.msort(a)</code>：沿第 1 个轴排序。</li>
<li><code>numpy.sort_complex(a)</code>：针对复数排序。</li>
</ul>
</blockquote>
<h3 id="搜索和计数"><a href="#搜索和计数" class="headerlink" title="搜索和计数"></a>搜索和计数</h3><blockquote>
<ul>
<li><code>argmax(a ,axis,out)</code>：返回数组中指定轴的最大值的索引。</li>
<li><code>nanargmax(a ,axis)</code>：返回数组中指定轴的最大值的索引,忽略 NaN。</li>
<li><code>argmin(a ,axis,out)</code>：返回数组中指定轴的最小值的索引。</li>
<li><code>nanargmin(a ,axis)</code>：返回数组中指定轴的最小值的索引,忽略 NaN。</li>
<li><code>argwhere(a)</code>：返回数组中非 0 元素的索引,按元素分组。</li>
<li><code>nonzero(a)</code>：返回数组中非 0 元素的索引。</li>
<li><code>flatnonzero(a)</code>：返回数组中非 0 元素的索引,并铺平。</li>
<li><code>where(条件,x,y)</code>：根据指定条件,从指定行、列返回元素。</li>
<li><code>searchsorted(a,v ,side,sorter)</code>：查找要插入元素以维持顺序的索引。</li>
<li><code>extract(condition,arr)</code>：返回满足某些条件的数组的元素。</li>
<li><code>count_nonzero(a)</code>：计算数组中非 0 元素的数量。</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Qijinli</p>
  <div class="site-description" itemprop="description">毕业于大连理工大学机械系，现从事人工智能开发，主要从事机器学习，计算机视觉，自然语言处理等多项领域。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qijinli</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
